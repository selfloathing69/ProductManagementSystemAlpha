# Шпаргалка для защиты MVVM

## Быстрые ответы на типовые вопросы

### ? Что такое MVVM?
**Ответ:** Архитектурный паттерн для WPF приложений. Разделяет приложение на:
- **Model** — бизнес-логика (Product, ProductLogic)
- **View** — UI без кода (XAML)
- **ViewModel** — связующий слой с командами и данными

**Главное:** View не знает о Model, Model не зависит от View.

---

### ? Что такое ViewModelFirst?
**Ответ:** Подход, где **ViewModel создается РАНЬШЕ View**.

**Алгоритм:**
1. Создаем ViewModel через DI
2. ViewManager создает View
3. View.DataContext = ViewModel
4. Показываем окно

**Где реализовано:** `App.xaml.cs` ? `OnStartup()`

---

### ? Зачем нужен ViewManager?
**Ответ:** Управление созданием окон.
- Создает View на основе ViewModel
- Устанавливает DataContext
- Централизованное управление UI

**Файл:** `ViewManager.cs`

---

### ? Зачем нужен BaseView?
**Ответ:** Базовый класс для всех окон.
- Единообразие
- Управление жизненным циклом
- Автоматическая установка DataContext

**Файл:** `BaseView.cs`

---

### ? Почему CodeBehind почти пустой?
**Ответ:** В MVVM вся логика в ViewModel, не в CodeBehind.

**MainWindow.xaml.cs содержит только:**
```csharp
public MainWindow() { InitializeComponent(); }
public MainWindow(MainViewModel vm) : base(vm) { InitializeComponent(); }
```

---

### ? Что такое Data Binding?
**Ответ:** Автоматическая связь View ? ViewModel.

```xaml
<TextBox Text="{Binding ProductName}" />
```

При изменении в UI ? обновляется ViewModel  
При изменении ViewModel ? обновляется UI

---

### ? Что такое Command Binding?
**Ответ:** Привязка кнопок к командам вместо событий.

```xaml
<Button Command="{Binding RefreshCommand}" />
```

Вместо `Button_Click` используем `ICommand`.

**Файл:** `RelayCommand.cs`

---

### ? Зачем нужен ProductDto?
**Ответ:** Для работы с View без изменения доменной модели.
- Реализует `INotifyPropertyChanged` для автообновления UI
- Доменная модель `Product` остается чистой (POCO)

**Файл:** `ProductDto.cs`

---

### ? Как работает INotifyPropertyChanged?
**Ответ:** Уведомляет View об изменениях.

```csharp
public string Name
{
    get => _name;
    set
    {
        _name = value;
        OnPropertyChanged(); // ? View обновляется автоматически
    }
}
```

---

### ? Где граф зависимостей?
**Ответ:** В `App.xaml.cs` ? `ConfigureDependencyInjection()`

```
MainViewModel
  ? требует ILogic
ProductLogic
  ? требует IRepository + IBusinessFunctions
EntityRepository + BusinessFunctions
```

**DI контейнер:** Ninject

---

### ? Как происходит запуск приложения?
**Ответ:** ViewModelFirst подход в `App.OnStartup()`:

```csharp
// 1. Настройка DI
ConfigureDependencyInjection();

// 2. Создание ViewManager
var viewManager = new ViewManager();

// 3. Создание ViewModel (ViewModelFirst!)
var mainViewModel = _kernel.Get<MainViewModel>();

// 4. ViewManager показывает окно
viewManager.ShowMainWindow(mainViewModel);
```

---

### ? В чем отличие от MVP?
**Ответ:**

| Аспект | MVP (WinForms) | MVVM (WPF) |
|--------|----------------|------------|
| Связь | События | Binding + Commands |
| CodeBehind | Обработчики | Минимален |
| Тестируемость | Сложнее | Проще |

---

### ? Какие SOLID принципы применены?
**Ответ:**
- **S** (Single Responsibility): BaseView, ViewManager, ViewModel — каждый одна задача
- **O** (Open-Closed): Расширение через наследование BaseView
- **D** (Dependency Inversion): DI контейнер (Ninject)

---

### ? Как данные попадают из БД в UI?
**Ответ:** Поток данных:

```
User нажимает "Обновить"
  ?
View: Command="{Binding RefreshCommand}"
  ?
ViewModel: RefreshCommand.Execute() ? LoadProducts()
  ?
Logic: _logic.GetAllProducts()
  ?
Repository: EntityRepository.GetAll()
  ?
Database: SELECT * FROM Products
  ?
Маппинг: Product ? ProductDto
  ?
ViewModel: Products.Add(dto)
  ?
View: DataGrid автоматически обновляется
```

---

### ? Что не тронуто согласно заданию?
**Ответ:** Слои DAL, Model, BusinessLogic — **не тронуты!**

Изменения **только** в WPF проекте:
- ? BaseView
- ? ViewManager
- ? MainViewModel
- ? ProductDto
- ? App.xaml.cs

---

### ? Почему ViewModel не знает о View?
**Ответ:** Для тестируемости и независимости.

ViewModel работает только с:
- ILogic (бизнес-логика)
- ProductDto (данные)
- ICommand (команды)

View создается ViewManager'ом и связывается через DataContext.

---

### ? Где находится бизнес-логика?
**Ответ:** В трех местах:
1. **Доменная логика:** `ProductLogic` (не тронута)
2. **Логика представления:** `MainViewModel` (команды, валидация)
3. **Логика View:** Отсутствует! (только XAML)

---

### ? Как добавить новое окно?
**Ответ:**
1. Создать `NewViewModel : ViewModelBase`
2. Создать `NewWindow : BaseView`
3. В ViewManager добавить метод:
```csharp
public void ShowNewWindow(NewViewModel vm)
{
    var window = new NewWindow(vm);
    window.Show();
}
```

---

## Ключевые файлы проекта

| Файл | Назначение |
|------|-----------|
| `App.xaml.cs` | Composition Root, ViewModelFirst |
| `BaseView.cs` | Базовый класс для окон |
| `ViewManager.cs` | Управление окнами |
| `MainViewModel.cs` | Логика главного окна |
| `ProductDto.cs` | DTO с INotifyPropertyChanged |
| `RelayCommand.cs` | Реализация ICommand |
| `MainWindow.xaml` | UI разметка (Binding) |
| `MainWindow.xaml.cs` | Минимальный CodeBehind |

---

## Самое важное на защите

### ?? Главная идея ViewModelFirst:
**ViewModel создается ДО View и не зависит от нее!**

### ?? Зачем MVVM:
**Полное разделение UI и бизнес-логики для тестируемости.**

### ?? Роль ViewManager:
**Создает окна на основе ViewModel.**

### ?? Почему CodeBehind пустой:
**Вся логика в ViewModel, не в CodeBehind!**

### ?? Зачем Binding:
**Автоматическая синхронизация View ? ViewModel.**

---

**Удачи на защите! ??**
